C51 COMPILER V9.57.0.0   KEY                                                               05/26/2025 23:37:18 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Objects\Key.obj
COMPILER INVOKED BY: E:\Study\Keil\keil c51\KeilData\C51\BIN\C51.EXE Key.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\Key.lst) OBJECT(.\Objects\Key.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Delay.h"
   3          #include "Motor.h"
   4          #include "Key.h"
   5          
   6          /**
   7           * @brief 获取按键状态并进行消抖处理
   8           * @return 返回按键状态码：
   9           *         -1: 无按键
  10           *         0: 逆时针按键按下
  11           *         1: 顺时针按键按下
  12           *         2: 两个按键同时按下
  13           *         3: 阈值上调按键按下
  14           *         4: 阈值下调按键按下
  15           */
  16          int get_key_status(void) {
  17   1          if (KEY_FWD == 0 && KEY_REV == 0) return BOTH_KEYS_PRESSED;  // 同时按下
  18   1          if (KEY_FWD == 0) return CLOCKWISE_KEY_PRESSED;              // 顺时针按下
  19   1          if (KEY_REV == 0) return ANTICLOCKWISE_KEY_PRESSED;          // 逆时针按下
  20   1          if (KEY_UP == 0) return THRESHOLD_UP_KEY_PRESSED;            // 阈值上调
  21   1          if (KEY_DOWN == 0) return THRESHOLD_DOWN_KEY_PRESSED;        // 阈值下调
  22   1          return NO_KEY_PRESSED;                                       // 无按键
  23   1      }
  24          
  25          /**
  26           * @brief 处理顺时针按键事件
  27           */
  28          void handle_fwd_key() {
  29   1          unsigned char i;
  30   1          // 连续执行24步顺时针旋转
  31   1          for(i = 0; i < 24; i++) {
  32   2              step_motor(DIRECTION_CW);  
  33   2              Delay_ms(20);  // 保持原有转速控制
  34   2          }
  35   1      }
  36          
  37          /**
  38           * @brief 处理逆时针按键事件
  39           */
  40          void handle_rev_key() {
  41   1          unsigned char i;
  42   1          // 连续执行24步逆时针旋转
  43   1          for(i = 0; i < 24; i++) {
  44   2              step_motor(DIRECTION_CCW); 
  45   2              Delay_ms(20);  // 保持原有转速控制
  46   2          }
  47   1      }
  48          
  49          /**
  50           * @brief 处理按键事件
  51           * @param last_key 上一次按键状态
  52           * @param current_key 当前按键状态
  53           * @param threshold 当前阈值
  54           */
C51 COMPILER V9.57.0.0   KEY                                                               05/26/2025 23:37:18 PAGE 2   

  55          void handle_key_events(int *last_key, int current_key, unsigned char *threshold) {
  56   1          // 如果当前没有按键按下，重置状态
  57   1          if (current_key == NO_KEY_PRESSED) {
  58   2              *last_key = NO_KEY_PRESSED;
  59   2              return;
  60   2          }
  61   1      
  62   1          // 如果当前两个键都按下，忽略动作
  63   1          if (current_key == BOTH_KEYS_PRESSED) {
  64   2              *last_key = BOTH_KEYS_PRESSED;
  65   2              return;
  66   2          }
  67   1      
  68   1          // 如果当前只有一个键按下，并且上一次未按下或不是同一种按键
  69   1          if (*last_key != current_key && *last_key != BOTH_KEYS_PRESSED) {
  70   2              // 延时5ms去抖动
  71   2              Delay_ms(5);
  72   2      
  73   2              // 如果当前按键仍然处于按下状态
  74   2              if (current_key == CLOCKWISE_KEY_PRESSED && KEY_FWD == 0) {
  75   3                  handle_fwd_key();
  76   3              } else if (current_key == ANTICLOCKWISE_KEY_PRESSED && KEY_REV == 0) {
  77   3                  handle_rev_key();
  78   3              } else if (current_key == THRESHOLD_UP_KEY_PRESSED && KEY_UP == 0) {
  79   3                  if (*threshold < 255) {
  80   4                      (*threshold)++;
  81   4                  }
  82   3              } else if (current_key == THRESHOLD_DOWN_KEY_PRESSED && KEY_DOWN == 0) {
  83   3                  if (*threshold > 0) {
  84   4                      (*threshold)--;
  85   4                  }
  86   3              }
  87   2          }
  88   1      
  89   1          *last_key = current_key;
  90   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    282    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
