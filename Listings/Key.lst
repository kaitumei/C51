C51 COMPILER V9.57.0.0   KEY                                                               05/26/2025 22:54:58 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\Objects\Key.obj
COMPILER INVOKED BY: E:\Study\Keil\keil c51\KeilData\C51\BIN\C51.EXE Key.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND P
                    -RINT(.\Listings\Key.lst) OBJECT(.\Objects\Key.obj)

line level    source

   1          #include <REGX52.H>
   2          #include "Delay.h"
   3          #include "Motor.h"
   4          #include "Key.h"
   5          
   6          /**
   7           * @brief 获取按键状态并进行消抖处理
   8           * @return 返回按键状态码：
   9           *         -1: 无按键
  10           *         0: 逆时针按键按下
  11           *         1: 顺时针按键按下
  12           *         2: 两个按键同时按下
  13           */
  14          int get_key_status(void) {
  15   1          if (KEY_FWD == 0 && KEY_REV == 0) return BOTH_KEYS_PRESSED;  // 同时按下
  16   1          if (KEY_FWD == 0) return CLOCKWISE_KEY_PRESSED;              // 顺时针按下
  17   1          if (KEY_REV == 0) return ANTICLOCKWISE_KEY_PRESSED;          // 逆时针按下
  18   1          return NO_KEY_PRESSED;                                       // 无按键
  19   1      }
  20          
  21          /**
  22           * @brief 处理顺时针按键事件
  23           */
  24          void handle_fwd_key() {
  25   1          unsigned char i;
  26   1          // 连续执行24步顺时针旋转
  27   1          for(i = 0; i < 24; i++) {
  28   2              step_motor(DIRECTION_CW);  
  29   2              Delay_ms(20);  // 保持原有转速控制
  30   2          }
  31   1      }
  32          
  33          /**
  34           * @brief 处理逆时针按键事件
  35           */
  36          void handle_rev_key() {
  37   1          unsigned char i;
  38   1          // 连续执行24步逆时针旋转
  39   1          for(i = 0; i < 24; i++) {
  40   2              step_motor(DIRECTION_CCW); 
  41   2              Delay_ms(20);  // 保持原有转速控制
  42   2          }
  43   1      }
  44          
  45          /**
  46           * @brief 处理按键事件
  47           * @param last_key 上一次按键状态
  48           * @param current_key 当前按键状态
  49           */
  50          void handle_key_events(int *last_key, int current_key) {
  51   1          // 如果当前没有按键按下，重置状态
  52   1          if (current_key == NO_KEY_PRESSED) {
  53   2              *last_key = NO_KEY_PRESSED;
  54   2              return;
C51 COMPILER V9.57.0.0   KEY                                                               05/26/2025 22:54:58 PAGE 2   

  55   2          }
  56   1      
  57   1          // 如果当前两个键都按下，忽略动作
  58   1          if (current_key == BOTH_KEYS_PRESSED) {
  59   2              *last_key = BOTH_KEYS_PRESSED;
  60   2              return;
  61   2          }
  62   1      
  63   1          // 如果当前只有一个键按下，并且上一次未按下或不是同一种按键
  64   1          if (*last_key != current_key && *last_key != BOTH_KEYS_PRESSED) {
  65   2              // 延时5ms去抖动
  66   2              Delay_ms(5);
  67   2      
  68   2              // 如果当前按键仍然处于按下状态
  69   2              if (current_key == CLOCKWISE_KEY_PRESSED && KEY_FWD == 0) {
  70   3                  handle_fwd_key();
  71   3              } else if (current_key == ANTICLOCKWISE_KEY_PRESSED && KEY_REV == 0) {
  72   3                  handle_rev_key();
  73   3              }
  74   2          }
  75   1      
  76   1          *last_key = current_key;
  77   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    203    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
